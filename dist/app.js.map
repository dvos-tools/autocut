{
  "version": 3,
  "sources": ["../src/events/consumer/subscription.ts", "../node_modules/uuid/dist/esm-node/rng.js", "../node_modules/uuid/dist/esm-node/stringify.js", "../node_modules/uuid/dist/esm-node/native.js", "../node_modules/uuid/dist/esm-node/v4.js", "../src/events/service/util.ts", "../src/events/bus/bus.ts", "../src/events/bus/index.ts", "../src/shortcuts/shortcutTriggerEvent.ts", "../src/index.ts"],
  "sourcesContent": ["import { EventBusI } from \"src/events/bus\"\n\nexport interface SubscriptionI {\n    unsubscribe(): void;\n}\n\nexport class Subscription implements SubscriptionI {\n    private key: string;\n    private eventBus: EventBusI;\n\n    constructor(eventBus: EventBusI, key: string) {\n        this.eventBus = eventBus;\n        this.key = key;\n    }\n\n    unsubscribe() {\n        this.eventBus.unsubscribe(this.key);\n    }\n}\n", "import crypto from 'crypto';\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\nexport default function rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    crypto.randomFillSync(rnds8Pool);\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}", "import validate from './validate.js';\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\n\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\n\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  return byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]];\n}\n\nfunction stringify(arr, offset = 0) {\n  const uuid = unsafeStringify(arr, offset); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nexport default stringify;", "import crypto from 'crypto';\nexport default {\n  randomUUID: crypto.randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\n\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n\n  options = options || {};\n  const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return unsafeStringify(rnds);\n}\n\nexport default v4;", "import { v4 as uuidv4 } from 'uuid';\n\nexport function generateKey(): string {\n    return uuidv4();\n}\n", "import { deafultEventBusOptions } from \"src/events/bus\"\nimport { SubscriptionI, Subscription } from \"src/events/consumer\"\nimport { generateKey } from \"src/events/service\"\nimport { EventHandler, EventBusOptions, EventI } from \"src/events/types\";\n\n\nexport interface EventBusI {\n    send(event: EventI): void;\n    subscribe<T extends EventI>(handler: EventHandler<T>): SubscriptionI;\n    unsubscribe(key: string): void;\n}\n\nexport class EventBus implements EventBusI {\n    private handlers: Map<string, EventHandler> = new Map();\n    private options: EventBusOptions;\n\n    constructor(options: EventBusOptions = deafultEventBusOptions) {\n        this.options = options;\n    }\n\n    send(event: EventI): void {\n        this.handlers.forEach((handler) => {\n            try {\n                handler(event);\n            } catch (error) {\n                console.error('Error in event handler:', error);\n            }\n        });\n    }\n\n    subscribe<T extends EventI>(handler: EventHandler<T>): SubscriptionI {\n        const key = generateKey();\n\n        if (this.options.processCurrentEventOnSubscribe) {\n            this.handlers.set(key, handler as EventHandler);\n        } else {\n            // Use queueMicrotask instead of setTimeout for better performance\n            queueMicrotask(() => this.handlers.set(key, handler as EventHandler));\n        }\n\n        return new Subscription(this, key);\n    }\n\n    unsubscribe(key: string): void {\n        if (!this.handlers.has(key)) {\n            console.warn(`Attempted to unsubscribe with invalid key: ${key}`);\n            return;\n        }\n        this.handlers.delete(key);\n    }\n}\n", "import { EventBusOptions } from \"src/events/types\"\n\nexport const deafultEventBusOptions: EventBusOptions = {\n    processCurrentEventOnSubscribe: false\n}\n\nexport * from \"./bus\"\n", "import { EventI } from \"src/events/types\"\n\nexport class ShortcutTriggerEvent implements EventI {\n\tpublic shortcutName: string;\n\n\tconstructor(shortcutName: string) {\n\t\tthis.shortcutName = shortcutName;\n\t}\n\n\thandle() {\n\t\tconsole.log(\"The event: \" + this.shortcutName + \" has been triggered.\")\n\t}\n}\n", "#!/usr/bin/env node\n\nimport { EventBus } from \"src/events/bus\";\nimport { ShortcutTriggerEvent } from \"src/shortcuts/shortcutTriggerEvent\";\n\nconst shortcutBus = new EventBus();\n\nfunction main(): void {\n\tshortcutBus.subscribe(handleShortcutTriggerEvent);\n\ttriggerShortcut(\"MyAmazingShortcut\");\n}\n\nfunction handleShortcutTriggerEvent(event: ShortcutTriggerEvent): void {\n\tconsole.log(`Shortcut triggered: ${event.shortcutName}`);\n\tevent.handle()\n}\n\nfunction triggerShortcut(shortcutName: string): void {\n\tconsole.log(`Triggering shortcut: ${shortcutName}`);\n\tconst shortcutEvent = new ShortcutTriggerEvent(shortcutName);\n\tshortcutBus.send(shortcutEvent);\n}\n\nmain(); \n"],
  "mappings": "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",
  "names": ["crypto", "import_crypto", "crypto"]
}
